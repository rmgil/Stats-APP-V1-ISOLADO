<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upload de HH - Stat Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #0a0a0a;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 0;
        }
        
        .navbar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .navbar-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .navbar-brand {
            color: white;
            text-decoration: none;
            font-size: 20px;
            font-weight: 500;
        }
        
        .navbar-menu {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .navbar-link {
            color: white;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .navbar-link:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .main-content {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: #111;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            padding: 40px;
            max-width: 500px;
            width: 100%;
            border: 1px solid #222;
        }
        
        h1 {
            color: #fff;
            text-align: center;
            margin-bottom: 30px;
            font-size: 24px;
            font-weight: 300;
        }
        
        .upload-area {
            border: 2px dashed #333;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: #0a0a0a;
        }
        
        .upload-area:hover,
        .upload-area.dragover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }
        
        .upload-area.dragover {
            transform: scale(1.01);
        }
        
        .upload-icon {
            width: 50px;
            height: 50px;
            margin: 0 auto 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .upload-icon svg {
            width: 24px;
            height: 24px;
            fill: white;
        }
        
        .upload-text {
            color: #e0e0e0;
            font-size: 15px;
            margin-bottom: 8px;
        }
        
        .upload-hint {
            color: #666;
            font-size: 13px;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .file-info {
            margin-top: 20px;
            padding: 16px;
            background: #0a0a0a;
            border-radius: 8px;
            display: none;
            border: 1px solid #222;
        }
        
        .file-info.show {
            display: block;
        }
        
        .file-name {
            font-weight: 500;
            color: #e0e0e0;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .file-size {
            color: #666;
            font-size: 13px;
        }
        
        .btn-analyze {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.2s, opacity 0.2s;
            display: none;
        }
        
        .btn-analyze.show {
            display: block;
        }
        
        .btn-analyze:hover:not(:disabled) {
            transform: translateY(-2px);
        }
        
        .btn-analyze:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        /* Progress Section */
        .progress-section {
            margin-top: 20px;
            display: none;
        }
        
        .progress-section.show {
            display: block;
        }
        
        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: rgba(26, 26, 26, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 15px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2, #667eea);
            background-size: 200% 100%;
            border-radius: 12px;
            width: 0%;
            position: relative;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.4);
            animation: gradient-shift 3s ease infinite;
        }
        
        .progress-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.3), transparent);
            border-radius: 12px 12px 0 0;
        }
        
        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: shimmer 2.5s ease-in-out infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateX(100%); opacity: 0; }
        }
        
        @keyframes gradient-shift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        /* Animated progress bar for processing */
        .progress-bar.progress-bar-animated {
            animation: gradient-shift 1.5s ease infinite, pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; }
        }
        
        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .progress-status {
            color: #b0b0b0;
            font-size: 13px;
            font-weight: 400;
            letter-spacing: 0.3px;
            transition: color 0.3s ease;
        }
        
        .progress-percentage {
            color: #667eea;
            font-size: 15px;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            letter-spacing: 0.5px;
            text-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .progress-steps {
            margin-top: 24px;
        }
        
        .progress-step {
            display: flex;
            align-items: center;
            margin-bottom: 14px;
            opacity: 0.3;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translateX(0);
        }
        
        .progress-step.active {
            opacity: 1;
            transform: translateX(2px);
        }
        
        .progress-step.completed {
            opacity: 0.6;
        }
        
        .step-icon {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: #1a1a1a;
            margin-right: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: #555;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .progress-step.active .step-icon {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.4), 
                        0 0 0 3px rgba(102, 126, 234, 0.1);
            animation: pulse-glow 2s ease-in-out infinite;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .progress-step.completed .step-icon {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            box-shadow: 0 2px 12px rgba(34, 197, 94, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        
        @keyframes pulse-glow {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 4px 16px rgba(102, 126, 234, 0.4), 
                            0 0 0 3px rgba(102, 126, 234, 0.1);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6), 
                            0 0 0 5px rgba(102, 126, 234, 0.15);
            }
        }
        
        .step-text {
            color: #666;
            font-size: 13px;
            font-weight: 400;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .progress-step.active .step-text {
            color: #e0e0e0;
            font-weight: 500;
        }
        
        .progress-step.completed .step-text {
            color: #888;
        }
        
        .error-message {
            background: #1a0808;
            color: #ff6b6b;
            padding: 14px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 13px;
            display: none;
            border: 1px solid #2a0808;
        }
        
        .error-message.show {
            display: block;
        }
        
        /* Minimal spinner for initial state */
        .spinner-small {
            width: 16px;
            height: 16px;
            border: 2px solid #333;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Breakout Game Styles */
        .game-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.98), rgba(30, 20, 50, 0.98));
            padding: 15px 20px;
            z-index: 1000;
            text-align: center;
            border-bottom: 2px solid #667eea;
            box-shadow: 0 10px 40px rgba(102, 126, 234, 0.4);
        }
        
        .game-container.show {
            display: block;
            animation: gameSlideIn 0.4s ease-out;
        }
        
        @keyframes gameSlideIn {
            from {
                opacity: 0;
                transform: translateY(-100%);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .game-title {
            color: #fff;
            margin-bottom: 8px;
            font-size: 22px;
            font-weight: 600;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .game-subtitle {
            color: #a0a0c0;
            font-size: 13px;
            margin-bottom: 18px;
        }
        
        .game-canvas {
            border: 2px solid #667eea;
            background: linear-gradient(180deg, #0a0a1a, #1a1a2e);
            border-radius: 10px;
            cursor: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .game-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            gap: 20px;
        }
        
        .game-stat {
            color: #fff;
            font-size: 14px;
            font-weight: 500;
        }
        
        .game-stat-label {
            color: #888;
            font-size: 12px;
            margin-bottom: 4px;
        }
        
        .game-stat-value {
            color: #667eea;
            font-size: 18px;
            font-weight: 600;
        }
        
        .game-close {
            margin-top: 15px;
            padding: 10px 24px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .game-close:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="navbar-container">
            <a href="/main" class="navbar-brand">Stat Manager</a>
            <div class="navbar-menu">
                <a href="/main" class="navbar-link">Dashboard</a>
                <a href="/upload" class="navbar-link">Nova An√°lise</a>
                {% if is_admin %}
                <a href="/admin/emails" class="navbar-link">Admin Panel</a>
                {% endif %}
                <a href="/auth/profile" class="navbar-link">Perfil</a>
                <a href="/auth/logout" class="navbar-link">Sair</a>
            </div>
        </div>
    </nav>
    
    <div class="main-content">
        <div class="container">
        <h1>Upload de HH</h1>
        
        <div class="upload-area" id="uploadArea">
            <div class="upload-icon">
                <svg viewBox="0 0 24 24">
                    <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                </svg>
            </div>
            <div class="upload-text">Arraste o seu ficheiro aqui</div>
            <div class="upload-hint">ou clique para seleccionar (ZIP/RAR)</div>
        </div>
        
        <input type="file" id="fileInput" accept=".zip,.rar">
        
        <div class="file-info" id="fileInfo">
            <div class="file-name">Ficheiro: <span id="fileName"></span></div>
            <div class="file-size">Tamanho: <span id="fileSize"></span></div>
        </div>
        
        <button class="btn-analyze" id="btnAnalyze">Analisar Ficheiro</button>
        
        <div class="progress-section" id="progressSection">
            <div class="progress-info">
                <span class="progress-status" id="progressStatus">A iniciar...</span>
                <span class="progress-percentage" id="progressPercentage">0%</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            
            <div class="progress-steps">
                <div class="progress-step" id="step-upload">
                    <div class="step-icon">1</div>
                    <div class="step-text">A enviar ficheiro</div>
                </div>
                <div class="progress-step" id="step-extract">
                    <div class="step-icon">2</div>
                    <div class="step-text">A extrair ficheiros</div>
                </div>
                <div class="progress-step" id="step-classify">
                    <div class="step-icon">3</div>
                    <div class="step-text">A classificar m√£os</div>
                </div>
                <div class="progress-step" id="step-parse">
                    <div class="step-icon">4</div>
                    <div class="step-text">A analisar estat√≠sticas</div>
                </div>
                <div class="progress-step" id="step-complete">
                    <div class="step-icon">‚úì</div>
                    <div class="step-text">A gerar dashboard</div>
                </div>
            </div>
        </div>
        
        <div class="error-message" id="errorMessage"></div>
    </div>
    
    <!-- Breakout Game -->
    <div class="game-container" id="gameContainer">
        <div class="game-title">üêç Snake</div>
        <div class="game-subtitle">Use as setas para controlar</div>
        <canvas id="gameCanvas" class="game-canvas" width="800" height="180"></canvas>
        <div class="game-stats">
            <div class="game-stat">
                <div class="game-stat-label">Pontos</div>
                <div class="game-stat-value" id="gameScore">0</div>
            </div>
            <div class="game-stat">
                <div class="game-stat-label">Vidas</div>
                <div class="game-stat-value" id="gameLives">3</div>
            </div>
        </div>
        <button class="game-close" onclick="hideGame()">Fechar</button>
    </div>
    
    <script>
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const btnAnalyze = document.getElementById('btnAnalyze');
        const progressSection = document.getElementById('progressSection');
        const progressBar = document.getElementById('progressBar');
        const progressStatus = document.getElementById('progressStatus');
        const progressPercentage = document.getElementById('progressPercentage');
        const errorMessage = document.getElementById('errorMessage');
        
        let selectedFile = null;
        let progressInterval = null;
        let elapsedTimeInterval = null;
        
        // Progress steps
        const steps = [
            { id: 'step-upload', text: 'A enviar ficheiro...', duration: 2000 },
            { id: 'step-extract', text: 'A extrair ficheiros...', duration: 3000 },
            { id: 'step-classify', text: 'A classificar m√£os...', duration: 4000 },
            { id: 'step-parse', text: 'A analisar estat√≠sticas...', duration: 5000 },
            { id: 'step-complete', text: 'A gerar dashboard...', duration: 1000 }
        ];
        
        // Click to upload
        uploadArea.addEventListener('click', () => {
            fileInput.click();
        });
        
        // Drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });
        
        // File input change
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });
        
        function handleFile(file) {
            const validExtensions = ['.zip', '.rar'];
            const fileExtension = file.name.toLowerCase().substr(file.name.lastIndexOf('.'));
            
            if (!validExtensions.includes(fileExtension)) {
                showError('Por favor, selecione um ficheiro ZIP ou RAR');
                return;
            }
            
            selectedFile = file;
            fileName.textContent = file.name;
            fileSize.textContent = formatFileSize(file.size);
            fileInfo.classList.add('show');
            btnAnalyze.classList.add('show');
            hideError();
        }
        
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' bytes';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }
        
        // Smooth progress animation system
        let currentDisplayProgress = 0;
        let targetProgress = 0;
        let animationFrameId = null;
        let progressHistory = [];
        let startTime = Date.now();
        
        function smoothProgressAnimation() {
            const speed = 0.15; // Interpolation speed (0.15 = smooth, responsive)
            
            if (Math.abs(targetProgress - currentDisplayProgress) > 0.1) {
                const diff = targetProgress - currentDisplayProgress;
                currentDisplayProgress += diff * speed;
                
                progressBar.style.width = currentDisplayProgress + '%';
                progressPercentage.textContent = Math.round(currentDisplayProgress) + '%';
                
                animationFrameId = requestAnimationFrame(smoothProgressAnimation);
            } else {
                // Animation complete - snap to target and reset frame ID
                currentDisplayProgress = targetProgress;
                progressBar.style.width = currentDisplayProgress + '%';
                progressPercentage.textContent = Math.round(currentDisplayProgress) + '%';
                animationFrameId = null; // Critical: allow next update to restart animation
            }
        }
        
        function updateProgress(newProgress) {
            const now = Date.now();
            targetProgress = newProgress;
            
            // Track progress history for ETA calculation
            progressHistory.push({
                percentage: newProgress,
                timestamp: now
            });
            
            // Keep only last 5 data points
            if (progressHistory.length > 5) {
                progressHistory.shift();
            }
            
            // Start smooth animation
            if (!animationFrameId) {
                animationFrameId = requestAnimationFrame(smoothProgressAnimation);
            }
            
            // Calculate and display ETA
            updateETA();
        }
        
        function updateETA() {
            if (progressHistory.length < 2) return;
            
            const firstPoint = progressHistory[0];
            const lastPoint = progressHistory[progressHistory.length - 1];
            
            const progressDiff = lastPoint.percentage - firstPoint.percentage;
            const timeDiff = (lastPoint.timestamp - firstPoint.timestamp) / 1000; // seconds
            
            if (progressDiff > 0 && timeDiff > 0) {
                const rate = progressDiff / timeDiff; // percentage per second
                const remaining = 100 - lastPoint.percentage;
                const eta = remaining / rate; // seconds
                
                let etaText = '';
                if (eta < 60) {
                    etaText = `~${Math.round(eta)}s restantes`;
                } else if (eta < 120) {
                    etaText = '~1min restante';
                } else {
                    etaText = `~${Math.round(eta / 60)}min restantes`;
                }
                
                // Update status with ETA
                const currentStage = document.querySelector('.progress-step.active .step-text');
                if (currentStage && targetProgress < 95) {
                    progressStatus.textContent = `${currentStage.textContent} ‚Ä¢ ${etaText}`;
                }
            }
        }
        
        function getContextualMessage(percentage, stage) {
            if (percentage < 15) return 'A iniciar an√°lise...';
            if (percentage < 40) return 'A processar ficheiros...';
            if (percentage < 70) return 'A analisar m√£os...';
            if (percentage < 95) return 'A calcular estat√≠sticas...';
            return 'A finalizar...';
        }
        
        // Map backend phases to frontend steps
        const phaseToStep = {
            'initializing': 'step-extract',
            'combining': 'step-extract',
            'assembling': 'step-extract',
            'extracting': 'step-classify',
            'classifying': 'step-classify',
            'analyzing': 'step-parse',
            'finalizing': 'step-complete',
            'processing': 'step-extract' // fallback
        };
        
        async function pollProgress(token, onComplete) {
            const startTime = Date.now();
            let elapsedTimeInterval;
            
            // Update elapsed time display every second
            elapsedTimeInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('progressPercentage').textContent = `‚è±Ô∏è ${timeStr}`;
            }, 1000);
            
            const pollInterval = setInterval(async () => {
                try {
                    // Use new progress endpoint served by FastAPI
                    const response = await fetch(`/api/upload/status/${token}`, {
                        credentials: 'include'
                    });
                    const data = await response.json();

                    if (!response.ok) {
                        clearInterval(pollInterval);
                        clearInterval(elapsedTimeInterval);
                        const errorDetail = data?.detail || data?.error || `Erro ao verificar progresso (${response.status})`;
                        showError(errorDetail);
                        return;
                    }

                    const serverProgress = data.progress ?? 0;
                    const status = data.status || 'processing';
                    const phase = data.phase || 'processing';
                    const message = data.message || 'A processar...';
                    const stats = data.stats || {};
                    
                    // TASKS 12-13: Show queue position when pending
                    if (status === 'pending' && data.queue) {
                        // Show queue position message (formatted by backend)
                        progressStatus.textContent = data.queue.message;
                        // Set progress to 5% to show activity while waiting in queue
                        updateDisplayProgress(5);
                        return; // Skip normal processing while in queue
                    }
                    
                    // Update progress bar
                    updateProgress(serverProgress);
                    
                    // Update status message with real backend message
                    let statusText = message;
                    if (stats.files_processed && stats.total_files) {
                        statusText += ` (${stats.files_processed}/${stats.total_files})`;
                    }
                    
                    // TASK 16: Add heartbeat timestamp when processing
                    if (status === 'processing' && data.heartbeat) {
                        const heartbeatTime = new Date(data.heartbeat);
                        const secondsAgo = Math.floor((Date.now() - heartbeatTime.getTime()) / 1000);
                        if (secondsAgo < 10) {
                            statusText += ' ‚Ä¢ Ativo agora';
                        } else if (secondsAgo < 60) {
                            statusText += ` ‚Ä¢ Ativo h√° ${secondsAgo}s`;
                        } else {
                            const minutesAgo = Math.floor(secondsAgo / 60);
                            statusText += ` ‚Ä¢ Ativo h√° ${minutesAgo}min`;
                        }
                    }
                    
                    progressStatus.textContent = statusText;
                    
                    // Update steps based on phase from backend
                    const currentStepId = phaseToStep[phase] || 'step-extract';
                    const allSteps = ['step-extract', 'step-classify', 'step-parse', 'step-complete'];
                    
                    // Mark previous steps as completed
                    const currentIndex = allSteps.indexOf(currentStepId);
                    allSteps.forEach((stepId, index) => {
                        const stepEl = document.getElementById(stepId);
                        if (index < currentIndex) {
                            stepEl.classList.add('completed');
                            stepEl.classList.remove('active');
                        } else if (index === currentIndex) {
                            stepEl.classList.add('active');
                            stepEl.classList.remove('completed');
                        } else {
                            stepEl.classList.remove('active', 'completed');
                        }
                    });
                    
                    // Check if complete
                    if (status === 'completed' && serverProgress >= 100) {
                        clearInterval(pollInterval);
                        clearInterval(elapsedTimeInterval);
                        if (animationFrameId) {
                            cancelAnimationFrame(animationFrameId);
                            animationFrameId = null;
                        }
                        
                        // Mark all steps as completed
                        allSteps.forEach(stepId => {
                            document.getElementById(stepId).classList.add('completed');
                            document.getElementById(stepId).classList.remove('active');
                        });
                        
                        progressStatus.textContent = 'Conclu√≠do! A redirecionar...';
                        
                        // Use result token if provided, otherwise use upload token
                        const resultToken = data.resultToken || token;
                        setTimeout(() => onComplete(resultToken), 500);
                    }
                    
                    // Check if failed
                    if (status === 'failed') {
                        clearInterval(pollInterval);
                        clearInterval(elapsedTimeInterval);
                        if (animationFrameId) {
                            cancelAnimationFrame(animationFrameId);
                            animationFrameId = null;
                        }
                        showError(data.error || 'Erro ao processar ficheiro');
                    }
                    
                } catch (error) {
                    console.error('Error polling progress:', error);
                    // Don't stop polling on network errors, just log them
                }
            }, 5000); // Poll every 5 seconds (intelligent polling)
            
            return { pollInterval, elapsedTimeInterval };
        }
        
        // Generate unique upload ID (12 hex characters)
        function generateUploadId() {
            // Generate 12 random hexadecimal characters (same format as Python's uuid.uuid4().hex[:12])
            const randomBytes = new Uint8Array(6); // 6 bytes = 12 hex chars
            crypto.getRandomValues(randomBytes);
            return Array.from(randomBytes)
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }
        
        // Simple direct upload function
        async function uploadFile(file) {
            // Step 1: Upload file directly
            progressStatus.textContent = 'A enviar ficheiro...';
            document.getElementById('step-upload').classList.add('active');
            
            const formData = new FormData();
            formData.append('file', file);
            
            const uploadResponse = await fetch('/api/upload/simple', {
                method: 'POST',
                credentials: 'include',
                body: formData
            });
            
            if (!uploadResponse.ok) {
                const errorData = await uploadResponse.json();
                throw new Error(errorData.error || 'Erro ao enviar ficheiro');
            }
            
            const uploadData = await uploadResponse.json();
            // New synchronous processing - upload completes immediately with results
            if (uploadData.success && uploadData.download_url) {
                // Processing completed during upload (synchronous)
                updateProgress(100);
                progressStatus.textContent = 'Processamento conclu√≠do!';
                
                // Mark all steps as complete
                ['step-upload', 'step-extract', 'step-classify', 'step-parse', 'step-complete'].forEach(stepId => {
                    document.getElementById(stepId).classList.add('completed');
                    document.getElementById(stepId).classList.remove('active');
                });
                
                // Redirect to results
                setTimeout(() => {
                    window.location.href = '/main';
                }, 1500);
                
                return null; // No need to poll
            }
            
            // Mark upload step as complete
            updateProgress(10);
            document.getElementById('step-upload').classList.add('completed');
            document.getElementById('step-upload').classList.remove('active');
            
            return uploadData.token; // Return the upload token
        }
        
        btnAnalyze.addEventListener('click', async () => {
            if (!selectedFile) return;
            
            btnAnalyze.disabled = true;
            btnAnalyze.style.display = 'none';
            progressSection.classList.add('show');
            hideError();
            
            // Reset progress variables
            currentDisplayProgress = 0;
            targetProgress = 0;
            progressHistory = [];
            startTime = Date.now();
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Reset UI
            progressBar.style.width = '0%';
            progressPercentage.textContent = '0%';
            progressStatus.textContent = 'A iniciar...';
            steps.forEach(step => {
                const element = document.getElementById(step.id);
                element.classList.remove('active', 'completed');
            });
            
            try {
                // Upload file directly (now processes synchronously)
                progressStatus.textContent = 'A processar ficheiro (pode demorar at√© 40 segundos)...';
                
                // Show spinner while processing
                progressBar.classList.add('progress-bar-animated');
                updateProgress(5); // Start with 5% to show activity
                
                // Simulate progress updates while waiting
                let simulatedProgress = 5;
                const progressSimulator = setInterval(() => {
                    simulatedProgress = Math.min(simulatedProgress + 2, 95);
                    updateProgress(simulatedProgress);
                    
                    // Update status messages based on simulated progress
                    if (simulatedProgress < 20) {
                        progressStatus.textContent = 'A carregar ficheiro...';
                    } else if (simulatedProgress < 40) {
                        progressStatus.textContent = 'A extrair arquivos...';
                    } else if (simulatedProgress < 60) {
                        progressStatus.textContent = 'A classificar ficheiros...';
                    } else if (simulatedProgress < 80) {
                        progressStatus.textContent = 'A analisar m√£os de poker...';
                    } else {
                        progressStatus.textContent = 'A finalizar processamento...';
                    }
                }, 1000);
                
                let uploadToken = null;
                try {
                    uploadToken = await uploadFile(selectedFile);
                    clearInterval(progressSimulator);
                } finally {
                    clearInterval(progressSimulator);
                    progressBar.classList.remove('progress-bar-animated');
                }
                
                // If token is null, upload already completed (synchronous)
                if (!uploadToken) {
                    return;
                }
                
                // Otherwise, start polling (legacy support)
                const intervals = pollProgress(uploadToken, () => {
                    // On complete, redirect to dashboard
                    window.location.href = '/main';
                });
                
                // Store intervals for cleanup if needed
                if (intervals) {
                    progressInterval = intervals.pollInterval;
                    elapsedTimeInterval = intervals.elapsedTimeInterval;
                }
                
                // Show Breakout game after 15 seconds
                setTimeout(() => {
                    showGame();
                }, 15000);
                
            } catch (error) {
                console.error('Upload error:', error);
                showError(error.message || 'Erro de conex√£o. Tente novamente.');
                progressSection.classList.remove('show');
                btnAnalyze.style.display = 'block';
                btnAnalyze.disabled = false;
            }
        });
        
        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.add('show');
        }
        
        function hideError() {
            errorMessage.classList.remove('show');
        }
        
        // Snake Game Logic
        let snakeGame = null;
        let gameActive = false;
        
        function showGame() {
            if (gameActive) return;
            
            const container = document.getElementById('gameContainer');
            container.classList.add('show');
            gameActive = true;
            
            initSnakeGame();
        }
        
        function hideGame() {
            const container = document.getElementById('gameContainer');
            container.classList.remove('show');
            gameActive = false;
            
            if (snakeGame) {
                snakeGame.stop();
                snakeGame = null;
            }
        }
        
        function initSnakeGame() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreElement = document.getElementById('gameScore');
            const livesElement = document.getElementById('gameLives');
            
            const gridSize = 18;
            const tileCount = {
                x: Math.floor(canvas.width / gridSize),
                y: Math.floor(canvas.height / gridSize)
            };
            
            let score = 0;
            let speed = 8;
            let gameLoopInterval;
            
            // Snake
            let snake = [
                {x: 10, y: 5},
                {x: 9, y: 5},
                {x: 8, y: 5}
            ];
            let direction = {x: 1, y: 0};
            let nextDirection = {x: 1, y: 0};
            
            // Food
            let food = spawnFood();
            
            function spawnFood() {
                let newFood;
                let validPosition = false;
                
                while (!validPosition) {
                    newFood = {
                        x: Math.floor(Math.random() * tileCount.x),
                        y: Math.floor(Math.random() * tileCount.y)
                    };
                    
                    validPosition = !snake.some(segment => 
                        segment.x === newFood.x && segment.y === newFood.y
                    );
                }
                
                return newFood;
            }
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (!gameActive) return;
                
                switch(e.key) {
                    case 'ArrowUp':
                        if (direction.y === 0) nextDirection = {x: 0, y: -1};
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                        if (direction.y === 0) nextDirection = {x: 0, y: 1};
                        e.preventDefault();
                        break;
                    case 'ArrowLeft':
                        if (direction.x === 0) nextDirection = {x: -1, y: 0};
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                        if (direction.x === 0) nextDirection = {x: 1, y: 0};
                        e.preventDefault();
                        break;
                }
            });
            
            function update() {
                direction = nextDirection;
                
                const head = {
                    x: snake[0].x + direction.x,
                    y: snake[0].y + direction.y
                };
                
                // Check wall collision
                if (head.x < 0 || head.x >= tileCount.x || 
                    head.y < 0 || head.y >= tileCount.y) {
                    gameOver();
                    return;
                }
                
                // Check self collision
                if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                    gameOver();
                    return;
                }
                
                snake.unshift(head);
                
                // Check food collision
                if (head.x === food.x && head.y === food.y) {
                    score += 10;
                    scoreElement.textContent = score;
                    food = spawnFood();
                    
                    // Increase speed slightly
                    if (speed < 15 && score % 50 === 0) {
                        speed++;
                        clearInterval(gameLoopInterval);
                        gameLoopInterval = setInterval(gameLoop, 1000 / speed);
                    }
                } else {
                    snake.pop();
                }
            }
            
            function draw() {
                // Background with grid
                const bgGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                bgGradient.addColorStop(0, '#0a0a1a');
                bgGradient.addColorStop(0.5, '#1a1a2e');
                bgGradient.addColorStop(1, '#0a0a1a');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw subtle grid
                ctx.strokeStyle = 'rgba(102, 126, 234, 0.1)';
                ctx.lineWidth = 1;
                for (let x = 0; x < tileCount.x; x++) {
                    for (let y = 0; y < tileCount.y; y++) {
                        ctx.strokeRect(x * gridSize, y * gridSize, gridSize, gridSize);
                    }
                }
                
                // Draw snake
                snake.forEach((segment, index) => {
                    const gradient = ctx.createLinearGradient(
                        segment.x * gridSize, 
                        segment.y * gridSize,
                        segment.x * gridSize + gridSize, 
                        segment.y * gridSize + gridSize
                    );
                    
                    if (index === 0) {
                        // Head
                        gradient.addColorStop(0, '#22c55e');
                        gradient.addColorStop(1, '#16a34a');
                    } else {
                        // Body
                        const alpha = 1 - (index / snake.length) * 0.3;
                        gradient.addColorStop(0, `rgba(102, 126, 234, ${alpha})`);
                        gradient.addColorStop(1, `rgba(118, 75, 162, ${alpha})`);
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(
                        segment.x * gridSize + 1, 
                        segment.y * gridSize + 1, 
                        gridSize - 2, 
                        gridSize - 2
                    );
                    
                    // Glow on head
                    if (index === 0) {
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#22c55e';
                        ctx.fillRect(
                            segment.x * gridSize + 1, 
                            segment.y * gridSize + 1, 
                            gridSize - 2, 
                            gridSize - 2
                        );
                        ctx.shadowBlur = 0;
                    }
                });
                
                // Draw food
                const foodGradient = ctx.createRadialGradient(
                    food.x * gridSize + gridSize / 2,
                    food.y * gridSize + gridSize / 2,
                    2,
                    food.x * gridSize + gridSize / 2,
                    food.y * gridSize + gridSize / 2,
                    gridSize / 2
                );
                foodGradient.addColorStop(0, '#fbbf24');
                foodGradient.addColorStop(1, '#f59e0b');
                
                ctx.fillStyle = foodGradient;
                ctx.beginPath();
                ctx.arc(
                    food.x * gridSize + gridSize / 2,
                    food.y * gridSize + gridSize / 2,
                    gridSize / 2 - 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Food glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#fbbf24';
                ctx.beginPath();
                ctx.arc(
                    food.x * gridSize + gridSize / 2,
                    food.y * gridSize + gridSize / 2,
                    gridSize / 2 - 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            function gameLoop() {
                if (!gameActive) return;
                update();
                draw();
            }
            
            function gameOver() {
                gameActive = false;
                clearInterval(gameLoopInterval);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Fim de Jogo!', canvas.width / 2, canvas.height / 2 - 20);
                ctx.font = '16px Arial';
                ctx.fillText(`Pontua√ß√£o: ${score}`, canvas.width / 2, canvas.height / 2 + 15);
                ctx.font = '12px Arial';
                ctx.fillStyle = '#999';
                ctx.fillText('Clique para jogar novamente', canvas.width / 2, canvas.height / 2 + 40);
                
                canvas.addEventListener('click', restartGame, {once: true});
            }
            
            function restartGame() {
                score = 0;
                speed = 8;
                scoreElement.textContent = '0';
                livesElement.textContent = snake.length;
                
                snake = [
                    {x: 10, y: 5},
                    {x: 9, y: 5},
                    {x: 8, y: 5}
                ];
                direction = {x: 1, y: 0};
                nextDirection = {x: 1, y: 0};
                food = spawnFood();
                
                gameActive = true;
                gameLoopInterval = setInterval(gameLoop, 1000 / speed);
            }
            
            snakeGame = {
                stop: () => {
                    gameActive = false;
                    clearInterval(gameLoopInterval);
                }
            };
            
            livesElement.textContent = snake.length;
            gameLoopInterval = setInterval(gameLoop, 1000 / speed);
        }
    </script>
    </div>
</body>
</html>