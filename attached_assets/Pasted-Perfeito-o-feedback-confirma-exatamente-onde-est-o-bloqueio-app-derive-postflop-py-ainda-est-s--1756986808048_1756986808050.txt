Perfeito — o feedback confirma exatamente onde está o bloqueio: app/derive/postflop.py ainda está só no skeleton, logo as stats de pós‑flop da DSL nunca encontram opportunity/attempt.
Abaixo tens prompts cirúrgicos para concluir a Fase 8 (núcleo pós‑flop), começando por Flop CBet (IP/OOP), vs CBet (fold/raise), Donk flop, Bet vs missed CBet (SRP) e WTSD. Isto é o suficiente para:

gerar opportunities > 0 em pós‑flop,

desbloquear percentagens reais no stats/stat_counts.json,

e o /pipeline passar a mostrar valores não-vazios para post‑flop.

Importante: Não mexe em nada das fases 1–7, nem na forma da DSL. Só preenchemos os sinais que a DSL já espera.

8.PF‑1 — Implementar app/derive/postflop.py (núcleo funcional)

Substitui o conteúdo atual pelo abaixo.

# app/derive/postflop.py
from typing import Dict, Any, List, Optional

AGGR = {"BET", "RAISE", "ALLIN"}      # ações agressivas
PASS = {"CHECK"}                      # passivas sem meter fichas
CALL = {"CALL"}                       # call
FOLD = {"FOLD"}                       # fold

def _street_actions(hand: Dict[str, Any], street: str) -> List[Dict[str, Any]]:
    s = (hand.get("streets") or {}).get(street) or {}
    return s.get("actions") or []

def _first_action_idx_by(hand_actions: List[Dict[str, Any]], player: str) -> Optional[int]:
    for i, a in enumerate(hand_actions):
        if a.get("actor") == player:
            return i
    return None

def _first_aggr_idx(actions: List[Dict[str, Any]]) -> Optional[int]:
    for i, a in enumerate(actions):
        if (a.get("type") or "").upper() in AGGR:
            return i
    return None

def _is_aggr(action: Dict[str, Any]) -> bool:
    return (action.get("type") or "").upper() in AGGR

def _is_fold(action: Dict[str, Any]) -> bool:
    return (action.get("type") or "").upper() in FOLD

def _is_call(action: Dict[str, Any]) -> bool:
    return (action.get("type") or "").upper() in CALL

def _is_check(action: Dict[str, Any]) -> bool:
    return (action.get("type") or "").upper() in PASS

def _actor_first_action(actions: List[Dict[str, Any]], actor: str) -> Optional[Dict[str, Any]]:
    idx = _first_action_idx_by(actions, actor)
    return actions[idx] if idx is not None else None

def _someone_bet_before(actions: List[Dict[str, Any]], idx_limit: int) -> bool:
    # Há BET/RAISE/ALLIN antes do índice idx_limit?
    if idx_limit is None:
        return False
    for i in range(idx_limit):
        if _is_aggr(actions[i]):
            return True
    return False

def _pfr_from_preflop_derived(hand: Dict[str, Any]) -> Optional[str]:
    dpf = (hand.get("derived") or {}).get("preflop") or {}
    # prioridade: 4bet > 3bet > open_raiser
    for k in ("four_bettor", "three_bettor", "open_raiser"):
        v = dpf.get(k)
        if v:
            return v
    # fallback: varrer preflop e apanhar último agressor
    pre = _street_actions(hand, "preflop")
    last_agg = None
    for a in pre:
        if _is_aggr(a):
            last_agg = a.get("actor")
    return last_agg

def _hero_is_ip_on(hand: Dict[str, Any], street: str) -> Optional[bool]:
    dip = (hand.get("derived") or {}).get("ip") or {}
    return dip.get(f"hero_ip_{street}")

def _saw_street(hand: Dict[str, Any], street: str) -> bool:
    return len(_street_actions(hand, street)) > 0

def _hero(hand: Dict[str, Any]) -> Optional[str]:
    return hand.get("hero")

def _players_to_flop(hand: Dict[str, Any]) -> int:
    dip = (hand.get("derived") or {}).get("ip") or {}
    return int(dip.get("players_to_flop") or 0)

def _pot_type(hand: Dict[str, Any]) -> str:
    dpf = (hand.get("derived") or {}).get("preflop") or {}
    return (dpf.get("pot_type") or "none").upper()

def _hero_faced_cbet_on_flop(hand: Dict[str, Any], pfr: str) -> bool:
    """Hero NÃO é PFR, primeiro bet no flop vem do PFR, antes do herói atuar."""
    hero = _hero(hand)
    flop = _street_actions(hand, "flop")
    if not flop or not hero or not pfr or hero == pfr:
        return False
    first_aggr_i = _first_aggr_idx(flop)
    if first_aggr_i is None:
        return False
    first_aggr = flop[first_aggr_i].get("actor")
    # tem de ser o PFR a apostar primeiro
    if first_aggr != pfr:
        return False
    hero_first_i = _first_action_idx_by(flop, hero)
    return hero_first_i is not None and first_aggr_i < hero_first_i

def _hero_response_after(actions: List[Dict[str, Any]], hero: str, after_idx: int) -> Optional[Dict[str, Any]]:
    for i in range(after_idx + 1, len(actions)):
        a = actions[i]
        if a.get("actor") == hero:
            return a
    return None

def _river_agg_pct(hand: Dict[str, Any]) -> Optional[float]:
    hero = _hero(hand)
    if not hero:
        return None
    river = _street_actions(hand, "river")
    if not river:
        return None
    hero_actions = [a for a in river if a.get("actor") == hero]
    if not hero_actions:
        return 0.0
    aggr = sum(1 for a in hero_actions if _is_aggr(a))
    return round(100.0 * aggr / max(1, len(hero_actions)), 2)

def _saw_showdown(hand: Dict[str, Any]) -> bool:
    # Heurística robusta: existe street 'showdown' OU alguma ação "SHOW"/"MUCK"
    streets = hand.get("streets") or {}
    if streets.get("showdown"):
        acts = (streets["showdown"] or {}).get("actions") or []
        if acts:
            return True
    # varre todas as streets à procura de SHOW/MUCK
    for st in ("river","turn","flop","preflop","showdown"):
        for a in _street_actions(hand, st):
            t = (a.get("type") or "").upper()
            if t in {"SHOW", "MUCK"}:
                return True
    return False

def _won_showdown(hand: Dict[str, Any]) -> Optional[bool]:
    # Se houver lista de vencedores, usa; caso contrário, devolve None (desconhecido)
    hero = _hero(hand)
    winners = hand.get("winners")
    if hero and isinstance(winners, list):
        return hero in winners
    return None

def _won_when_saw_flop(hand: Dict[str, Any]) -> Optional[bool]:
    # Melhor esforço: se winners existir, usa. Se não, não inferimos (None).
    if not _saw_street(hand, "flop"):
        return None
    hero = _hero(hand)
    winners = hand.get("winners")
    if hero and isinstance(winners, list):
        return hero in winners
    return None

def derive_postflop(hand: Dict[str, Any]) -> Dict[str, Any]:
    """
    Núcleo mínimo viável para ativar as stats de pós‑flop da DSL:
      - PFR (preflop raiser)
      - Flop CBet (IP/OOP) opportunity & attempt
      - vs CBet (fold/raise) IP/OOP
      - Donk flop
      - Bet vs missed CBet (SRP)
      - WTSD, W$SD?, W$WSF?, River Agg %
    """
    hero = _hero(hand)
    flop = _street_actions(hand, "flop")
    saw_flop = _saw_street(hand, "flop")
    hero_ip_flop = _hero_is_ip_on(hand, "flop")
    pfr = _pfr_from_preflop_derived(hand)
    pot_type = _pot_type(hand)  # "SRP", "3BET", ...

    d: Dict[str, Any] = {
        "pfr_player": pfr,

        # CBet flop (opp/att) IP/OOP
        "cbet_flop_opp_ip": False,
        "cbet_flop_att_ip": False,
        "cbet_flop_opp_oop": False,
        "cbet_flop_att_oop": False,

        # Turn placeholders (a implementar depois)
        "cbet_turn_opp_ip": False,
        "cbet_turn_att_ip": False,
        "cbet_turn_opp_oop": False,
        "cbet_turn_att_oop": False,

        # Donk
        "donk_flop": False,
        "donk_turn": False,

        # vs CBet flop (fold/raise) IP/OOP
        "vs_cbet_flop_fold_ip": False,
        "vs_cbet_flop_raise_ip": False,
        "vs_cbet_flop_fold_oop": False,
        "vs_cbet_flop_raise_oop": False,

        # Missed cbet SRP linhas
        "flop_bet_vs_missed_cbet_srp": False,
        "turn_bet_vs_missed_cbet_srp_oop": False,  # placeholder

        # Showdown / W$WSF
        "saw_flop": bool(saw_flop),
        "saw_showdown": _saw_showdown(hand),
        "won_showdown": _won_showdown(hand),
        "won_when_saw_flop": _won_when_saw_flop(hand),

        # River Agg %
        "river_agg_pct": _river_agg_pct(hand),
    }

    if not hero or not saw_flop or not flop:
        return d

    # ---------- FLOP CBET (Hero como PFR) ----------
    if pfr and hero == pfr:
        # Índice da 1ª ação do HERO no flop
        h_i = _first_action_idx_by(flop, hero)
        if h_i is not None:
            nobody_bet_before_hero = not _someone_bet_before(flop, h_i)
            if nobody_bet_before_hero:
                # Opportunity: herói (PFR) chega à sua 1ª ação sem apostar prévia de terceiros
                if hero_ip_flop is True:
                    d["cbet_flop_opp_ip"] = True
                elif hero_ip_flop is False:
                    d["cbet_flop_opp_oop"] = True
                # Attempt: se a 1ª ação do HERO no flop é agressiva
                first = flop[h_i]
                if _is_aggr(first):
                    if hero_ip_flop is True:
                        d["cbet_flop_att_ip"] = True
                    elif hero_ip_flop is False:
                        d["cbet_flop_att_oop"] = True

    # ---------- VS CBET (Hero NÃO é PFR) ----------
    if pfr and hero != pfr:
        first_aggr_i = _first_aggr_idx(flop)
        if first_aggr_i is not None:
            first_bettor = flop[first_aggr_i].get("actor")
            # Consideramos "cbet contra" se o primeiro agressor for o PFR
            if first_bettor == pfr:
                # Índice da 1ª ação do HERO no flop (resposta)
                h_i = _first_action_idx_by(flop, hero)
                if h_i is not None and first_aggr_i < h_i:
                    # Opportunity: faced cbet
                    resp = flop[h_i]
                    if hero_ip_flop is True:
                        # attempts: fold/raise
                        if _is_fold(resp):
                            d["vs_cbet_flop_fold_ip"] = True
                        elif _is_aggr(resp):
                            d["vs_cbet_flop_raise_ip"] = True
                        # (call fica de fora destas stats)
                    elif hero_ip_flop is False:
                        if _is_fold(resp):
                            d["vs_cbet_flop_fold_oop"] = True
                        elif _is_aggr(resp):
                            d["vs_cbet_flop_raise_oop"] = True

    # ---------- DONK FLOP (Hero não é PFR, OOP, e aposta antes do PFR agir) ----------
    if pfr and hero != pfr and hero_ip_flop is False:
        h_i = _first_action_idx_by(flop, hero)
        pfr_i = _first_action_idx_by(flop, pfr)
        if h_i is not None and (pfr_i is None or h_i < pfr_i):
            first = flop[h_i]
            if _is_aggr(first):
                d["donk_flop"] = True

    # ---------- FLOP BET VS MISSED CBET (SRP) ----------
    # Definição: pot SRP, PFR não aposta no flop e hero (IP) aposta quando chega a ação (após checks).
    if pot_type == "SRP" and pfr:
        # O PFR não pode ter feito a 1ª aposta no flop.
        first_aggr_i = _first_aggr_idx(flop)
        pfr_first_i = _first_action_idx_by(flop, pfr)
        if hero_ip_flop is True and pfr_first_i is not None:
            # Ninguém apostou até à ação do HERO, e a ação chega ao HERO (índice do HERO > pfr_i)
            h_i = _first_action_idx_by(flop, hero)
            if h_i is not None:
                nobody_bet_before_hero = not _someone_bet_before(flop, h_i)
                # PFR não apostou até o HERO agir
                pfr_bet_before_hero = False
                if pfr_first_i is not None:
                    for i in range(pfr_first_i, min(h_i, len(flop))):
                        if flop[i].get("actor") == pfr and _is_aggr(flop[i]):
                            pfr_bet_before_hero = True
                            break
                if nobody_bet_before_hero and not pfr_bet_before_hero:
                    # Attempt se o HERO aposta
                    if _is_aggr(flop[h_i]):
                        d["flop_bet_vs_missed_cbet_srp"] = True

    return d


O que isto cobre agora (já ativando a DSL existente):

POST_CBET_FLOP_IP, POST_CBET_FLOP_OOP

POST_VS_CBET_FLOP_FOLD_IP/OOP, POST_VS_CBET_FLOP_RAISE_IP/OOP

POST_BET_VS_MISSED_CBET_SRP_FLOP

POST_DONK_FLOP

POST_WTSD (via saw_showdown)

POST_RIVER_AGG_PCT (valor numérico %)

Turn e linhas de river bet single raised pot, W$SD, W$WSF podem entrar numa 8.2; com o acima já tens o core de pós‑flop a produzir oportunidades.

8.PF‑2 — Ligar o derivado pós‑flop no runner (se ainda não estiver)

Garante que em app/derive/runner.py depois de preencher positions, preflop, ip, stacks tens algo como:

from app.derive.postflop import derive_postflop

post = derive_postflop(hand)
derived["postflop"] = post


O teu assistant indicou que o wire‑up já existia; confirma apenas.

8.PF‑3 — (Opcional) DSL mínima para smoke test

Se precisares de um smoke imediato (caso a tua DSL postflop ainda não esteja no stats.yml), adiciona estes blocos:

# app/stats/dsl/stats.yml  (acrescentar)
  - id: POST_CBET_FLOP_IP
    label: "Flop CBet IP %"
    family: "POSTFLOP_CBET"
    scope: postflop
    applies_to_groups: ["postflop_all"]
    filters: {}
    opportunity: { is_true: "cbet_flop_opp_ip" }
    attempt:    { is_true: "cbet_flop_att_ip" }

  - id: POST_VS_CBET_FLOP_FOLD_IP
    label: "Flop fold vs Cbet (IP)"
    family: "POSTFLOP_VS_CBET"
    scope: postflop
    applies_to_groups: ["postflop_all"]
    filters: {}
    opportunity:
      # oportunidade implícita: faced cbet IP ⇒ detectada pelo próprio sinal de attempt/fold
      is_true: "vs_cbet_flop_fold_ip"
    attempt: { is_true: "vs_cbet_flop_fold_ip" }

  - id: POST_DONK_FLOP
    label: "Donk bet Flop"
    family: "POSTFLOP_DONK"
    scope: postflop
    applies_to_groups: ["postflop_all"]
    filters: {}
    opportunity: { is_true: "donk_flop" }
    attempt:    { is_true: "donk_flop" }

  - id: POST_BET_VS_MISSED_CBET_SRP_FLOP
    label: "Flop bet vs missed CBet (SRP)"
    family: "POSTFLOP_MISSED_CBET"
    scope: postflop
    applies_to_groups: ["postflop_all"]
    filters: { pot_type: ["SRP"] }
    opportunity: { is_true: "flop_bet_vs_missed_cbet_srp" }
    attempt:    { is_true: "flop_bet_vs_missed_cbet_srp" }

  - id: POST_WTSD
    label: "WTSD%"
    family: "POSTFLOP_RIVER"
    scope: postflop
    applies_to_groups: ["postflop_all"]
    filters: {}
    opportunity: { is_true: "saw_flop" }
    attempt:    { is_true: "saw_showdown" }

  - id: POST_RIVER_AGG_PCT
    label: "River Agg %"
    family: "POSTFLOP_RIVER"
    scope: postflop
    applies_to_groups: ["postflop_all"]
    # métrica direta (não é ratio). O engine vai colocar "percentage" mas podes tratá-lo como valor absoluto.
    filters: {}
    opportunity: { is_true: "saw_flop" }
    attempt:
      # considera attempt se river_agg_pct não for None (contabiliza ocorrência para média externa / leitura do valor)
      is_true: "saw_flop"


Se a tua DSL postflop já existe com estes IDs/sinais, não repitas — deixa como está.

8.PF‑4 — Testes sintéticos mínimos (ativar pós‑flop)

tests/test_postflop_derive_minimal.py

import json
from app.derive.postflop import derive_postflop

def make_hand_flop_cbet_ip():
    # Hero é PFR, flop heads-up, villain check, hero bet ⇒ CBet IP
    return {
        "hero": "Hero",
        "players": [{"name":"Hero"},{"name":"Villain"}],
        "derived": {
            "preflop": {"open_raiser":"Hero","pot_type":"SRP"},
            "ip": {"hero_ip_flop": True, "players_to_flop": 2}
        },
        "streets": {
            "preflop": {"actions":[{"actor":"Hero","type":"RAISE"},{"actor":"Villain","type":"CALL"}]},
            "flop":    {"actions":[{"actor":"Villain","type":"CHECK"},{"actor":"Hero","type":"BET","amount":2.0}]}
        }
    }

def make_hand_vs_cbet_fold_ip():
    # Villain é PFR e aposta primeiro no flop; Hero IP e faz FOLD
    return {
        "hero": "Hero",
        "players": [{"name":"Hero"},{"name":"Villain"}],
        "derived": {
            "preflop": {"open_raiser":"Villain","pot_type":"SRP"},
            "ip": {"hero_ip_flop": True, "players_to_flop": 2}
        },
        "streets": {
            "preflop": {"actions":[{"actor":"Villain","type":"RAISE"},{"actor":"Hero","type":"CALL"}]},
            "flop":    {"actions":[{"actor":"Villain","type":"BET","amount":2.0},{"actor":"Hero","type":"FOLD"}]}
        }
    }

def test_cbet_flop_ip():
    hand = make_hand_flop_cbet_ip()
    d = derive_postflop(hand)
    assert d["cbet_flop_opp_ip"] is True
    assert d["cbet_flop_att_ip"] is True
    assert d["donk_flop"] is False

def test_vs_cbet_fold_ip():
    hand = make_hand_vs_cbet_fold_ip()
    d = derive_postflop(hand)
    assert d["vs_cbet_flop_fold_ip"] is True
    assert d["vs_cbet_flop_raise_ip"] is False
    assert d["cbet_flop_opp_ip"] is False

def test_wtsd_flag():
    hand = make_hand_flop_cbet_ip()
    # adiciona showdown 'SHOW' para disparar WTSD
    hand["streets"]["showdown"] = {"actions":[{"actor":"Hero","type":"SHOW"}]}
    d = derive_postflop(hand)
    assert d["saw_flop"] is True
    assert d["saw_showdown"] is True

8.PF‑5 — Como validar no teu ambiente

Re‑enriquecer:
POST /api/derive/build com in_jsonl=parsed/hands.jsonl → parsed/hands_enriched.jsonl.

Re‑particionar:
POST /api/partition usando o hands_enriched.jsonl.

Re‑calcular stats:
POST /api/stats/build (a DSL já tem post‑flop).

Re‑pontuar:
POST /api/score/build.

Em /pipeline, o Resumo deve agora mostrar valores preenchidos também para postflop_all.
Se quiseres inspeccionar oportunidades/attempts: /api/stats/hands com group=postflop_all e stat=POST_CBET_FLOP_IP → devolve .ids para click‑through.

O que fica para 8.2 (opcional, depois do “core”)

Turn CBet (opp/att IP/OOP) com dependência do flop aggressor real;

Donk Turn, Bet turn vs missed flop cbet OOP SRP, Turn fold vs cbet OOP;

W$SD% (exige winners conclusivos) e W$WSF (quando vimos flop e ganhámos, showdown ou não);

River bet – single raised pot (detectar SRP e aposta no river);

Check‑raise (fold vs check‑raise).

Definition of Done — Fase 8 (core pós‑flop)

 derive_postflop() a marcar cbet flop IP/OOP, vs cbet fold/raise, donk flop, bet vs missed cbet SRP, WTSD e river_agg_pct.

 stats/stat_counts.json com oportunidades >0 em pelo menos POST_CBET_FLOP_IP.

 /pipeline a mostrar postflop_all com percentagens > 0.

 Testes mínimos a passar.

Quando confirmares que os números aparecem no pipeline, avançamos para Fase 8.2 (turn/river avançado) ou diretamente para Fase 9 (UI “pro” de dashboards e tuning visual) — como preferires.