7.A – Criar o módulo app/hands/ (index + serviço)

Cria os ficheiros:

app/hands/__init__.py
app/hands/indexer.py
app/hands/service.py
app/hands/api.py


app/hands/indexer.py

# app/hands/indexer.py
import os, json, logging
from typing import Dict

logger = logging.getLogger("hands.indexer")

def build_index(hands_jsonl: str, out_path: str) -> Dict:
    """
    Lê parsed/hands_enriched.jsonl e gera um índice:
      hand_id -> { offset, file_id, tournament_id, site }
    """
    index = {"meta": {"input": hands_jsonl, "count": 0}, "map": {}}
    with open(hands_jsonl, "rb") as f:
        while True:
            pos = f.tell()
            line = f.readline()
            if not line:
                break
            try:
                obj = json.loads(line.decode("utf-8"))
                hid = obj.get("hand_id") or obj.get("id")
                if not hid:
                    continue
                index["map"][hid] = {
                    "offset": pos,
                    "file_id": obj.get("file_id"),
                    "tournament_id": obj.get("tournament_id"),
                    "site": obj.get("site"),
                }
                index["meta"]["count"] += 1
            except Exception as e:
                logger.warning(f"Erro a indexar @ {pos}: {e}")

    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    with open(out_path, "w", encoding="utf-8") as fo:
        json.dump(index, fo, ensure_ascii=False, indent=2)
    return index

def fetch_by_id(hands_jsonl: str, index: Dict, hand_id: str) -> dict:
    entry = (index or {}).get("map", {}).get(hand_id)
    if not entry:
        return {}
    with open(hands_jsonl, "rb") as f:
        f.seek(entry["offset"])
        line = f.readline()
    return json.loads(line.decode("utf-8"))


app/hands/service.py

# app/hands/service.py
import os, json, logging, chardet
from typing import Optional

logger = logging.getLogger("hands.service")

# Ajusta se necessário conforme a tua árvore de deploy
SAFE_ROOTS = [
    "CLASSIFIED",
    "parsed",
    "/tmp",
]

def is_safe_path(p: str) -> bool:
    p = os.path.abspath(p)
    for root in SAFE_ROOTS:
        if os.path.exists(root) and os.path.abspath(p).startswith(os.path.abspath(root)):
            return True
    return False

def _read_bytes(path: str) -> bytes:
    with open(path, "rb") as f:
        return f.read()

def read_text_auto(path: str) -> str:
    raw = _read_bytes(path)
    det = chardet.detect(raw) or {}
    enc = det.get("encoding") or "utf-8"
    try:
        return raw.decode(enc, errors="replace")
    except Exception:
        return raw.decode("utf-8", errors="replace")

def slice_by_offsets(text: str, start: int, end: int, context: int = 200) -> str:
    s = max(0, start - context)
    e = min(len(text), end + context)
    return text[s:e]

def find_source_path(file_id: Optional[str]) -> Optional[str]:
    if not file_id:
        return None
    if os.path.isabs(file_id) and os.path.exists(file_id):
        return file_id
    # tenta combinar com roots seguras
    for root in SAFE_ROOTS:
        guess = os.path.join(root, file_id)
        if os.path.exists(guess):
            return guess
    # fallback por nome
    fname = os.path.basename(file_id)
    for root in SAFE_ROOTS:
        for base, _, files in os.walk(root):
            if fname in files:
                return os.path.join(base, fname)
    return None

def build_excerpt(hand: dict, context_chars: int = 200) -> dict:
    file_id = hand.get("file_id")
    raw_off = (hand.get("raw_offsets") or {})
    hstart = int(raw_off.get("hand_start", -1))
    hend   = int(raw_off.get("hand_end", -1))

    if hstart < 0 or hend < 0:
        return {"error": "Offsets indisponíveis"}

    src = find_source_path(file_id)
    if not src or not is_safe_path(src):
        return {"error": "Ficheiro original não encontrado/fora de raiz segura"}

    text = read_text_auto(src)
    snippet = slice_by_offsets(text, hstart, hend, context=context_chars)

    hero = hand.get("hero")
    if hero:
        snippet = snippet.replace(hero, f"[HERO:{hero}]")

    return {
        "file": src,
        "from": hstart, "to": hend,
        "length": max(0, hend - hstart),
        "snippet": snippet
    }


app/hands/api.py

# app/hands/api.py
import os, json
from flask import Blueprint, request, jsonify
from app.hands.indexer import build_index, fetch_by_id

bp = Blueprint("hands_api", __name__)

INDEX_PATH   = "parsed/hands_index.json"
HANDS_JSONL  = "parsed/hands_enriched.jsonl"

_INDEX_CACHE = None

def _ensure_index():
    global _INDEX_CACHE
    if _INDEX_CACHE is None:
        if not os.path.exists(INDEX_PATH):
            build_index(HANDS_JSONL, INDEX_PATH)
        _INDEX_CACHE = json.load(open(INDEX_PATH, "r", encoding="utf-8"))
    return _INDEX_CACHE

@bp.route("/api/hh/reindex", methods=["POST"])
def api_reindex():
    data = request.get_json(silent=True) or {}
    in_jsonl = data.get("in_jsonl", HANDS_JSONL)
    out_idx  = data.get("out_index", INDEX_PATH)
    res = build_index(in_jsonl, out_idx)
    global _INDEX_CACHE
    _INDEX_CACHE = res
    return jsonify({"success": True, "indexed": res["meta"]["count"], "index": out_idx})

@bp.route("/api/hh", methods=["GET"])
def api_get_hand():
    hand_id = request.args.get("id")
    if not hand_id:
        return jsonify({"error": "id em falta"}), 400
    idx = _ensure_index()
    if hand_id not in idx.get("map", {}):
        return jsonify({"error": "hand_id desconhecido"}), 404
    obj = fetch_by_id(HANDS_JSONL, idx, hand_id)
    keep = {k: obj.get(k) for k in [
        "hand_id","site","tournament_id","file_id","hero",
        "button_seat","table_max","blinds","derived","timestamp_utc","raw_offsets"
    ]}
    return jsonify(keep)

@bp.route("/api/hh/excerpt", methods=["GET"])
def api_get_excerpt():
    from app.hands.indexer import fetch_by_id
    from app.hands.service import build_excerpt

    hand_id = request.args.get("id")
    ctx = int(request.args.get("context", "200"))
    if not hand_id:
        return jsonify({"error": "id em falta"}), 400
    idx = _ensure_index()
    if hand_id not in idx.get("map", {}):
        return jsonify({"error": "hand_id desconhecido"}), 404
    obj = fetch_by_id(HANDS_JSONL, idx, hand_id)
    ex = build_excerpt(obj, context_chars=ctx)
    if "error" in ex:
        return jsonify(ex), 404
    return jsonify(ex)